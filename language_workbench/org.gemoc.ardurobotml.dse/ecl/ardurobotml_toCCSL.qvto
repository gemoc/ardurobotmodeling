import fr.inria.aoste.timesquare.ecl.EclQVToHelper;
 
	
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
//modeltype pivot uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';

	modeltype inMM1 uses 'http://org.gemoc/ardurobotml';


//modeltype inMM uses 'http://org.gemoc/ardurobotml';
modeltype QVT uses 'http://www.eclipse.org/QVT/1.0.0/Operational';//http://www.eclipse.org/m2m/qvt/oml/1.0.0/Stdlib';//http://www.eclipse.org/qvt/1.0/ImperativeOCL'; 
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';

modeltype FeedBack uses 'http://timesquare.inria.fr/feedback';

transformation doArdurobotml_ecore_To_CCSL(in inM : inMM1, out ccsl : TimeModel, out feedback : FeedBack);
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};

property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;

property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;

property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM1::Package]->asSequence()->first()-> map ardurobotml2CCSL();
	inM.rootObjects()[inMM1::Package]->asSequence()->first()-> map ardurobotml2FeedBack();

	}

			
	mapping inMM1::Package::ardurobotml2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		////[ FSMClock ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FSMClock.oclAsType(EClass)).oclAsType(FSMClock)->map tickClock2Clock();
		


		

		////[ TFSM ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), TFSM.oclAsType(EClass)).oclAsType(TFSM)->map initializeEvent2Clock();
		


		

		////[ Action ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map beginClock2Clock();
		////[ Action ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map endClock2Clock();
		


		

		////[ State ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map enteringClock2Clock();
		////[ State ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map leavingClock2Clock();
		


		

		////[ Transition ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Transition.oclAsType(EClass)).oclAsType(Transition)->map fireClock2Clock();
		


		

		////[ FSMEvent ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FSMEvent.oclAsType(EClass)).oclAsType(FSMEvent)->map happenedClock2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FSMEvent.oclAsType(EClass)).oclAsType(FSMEvent)->map noTickingUntilFSMInitialized252noTickingUntilFSMInitialized();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map beginThenEndInvariant12beginThenEndInvariant();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map tickAfterLast882tickAfterLast();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), TFSM.oclAsType(EClass)).oclAsType(TFSM)->map initializeOnlyOnceInvariant82initializeOnlyOnceInvariant();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), TFSM.oclAsType(EClass)).oclAsType(TFSM)->map initFirstInvariant12initFirstInvariant();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), TFSM.oclAsType(EClass)).oclAsType(TFSM)->map oneTransitionAtATime12oneTransitionAtATime();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map enterThenLeaveInvariant12enterThenLeaveInvariant();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map oneActionAtATime12oneActionAtATime();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map tickWhenEnteringState272tickWhenEnteringState();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map leaveWhenOneTransitionFires252leaveWhenOneTransitionFires();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map enterWhenOneTransitionFires252enterWhenOneTransitionFires();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Transition.oclAsType(EClass)).oclAsType(Transition)->map fireWhenLasActionEnds492fireWhenLasActionEnds();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Transition.oclAsType(EClass)).oclAsType(Transition)->map fireWhenEventHappens502fireWhenEventHappens();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Transition.oclAsType(EClass)).oclAsType(Transition)->map fireWhenNoGuard222fireWhenNoGuard();
		
	}





//create the expressions...
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::FSMEvent::intermediate_firstHappenedClock2Expression(an1 : FSMEvent, an2 : FSMEvent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_firstHappenedClock'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_happenedClock']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::FSMEvent::intermediate_firstHappenedClock2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : FSMEvent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_firstHappenedClock'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					_abstract := seqOfExpressionDeclaration[name = 'OneTickAndNoMore']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::FSMEvent::firstHappenedClock2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(FSMEvent) := self->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_firstHappenedClock2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_firstHappenedClock2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_firstHappenedClock2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::TFSM::intermediate_oneTickOnlyClock2Expression(an1 : TFSM, an2 : TFSM, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneTickOnlyClock'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_initializeEvent']->first();
					_abstract := seqOfAbstractEntity[name = 'OneTickAndNoMoreClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'OneTickAndNoMore']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::TFSM::intermediate_oneTickOnlyClock2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : TFSM, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneTickOnlyClock'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "OneTickAndNoMore")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					_abstract := seqOfExpressionDeclaration[name = 'OneTickAndNoMore']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::TFSM::oneTickOnlyClock2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(TFSM) := self->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_oneTickOnlyClock2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_oneTickOnlyClock2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_oneTickOnlyClock2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::State::intermediate_allOutgoingTransition2Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fireClock']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fireClock']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::State::intermediate_allOutgoingTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allOutgoingTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fireClock']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::State::allOutgoingTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.outgoingTransitions->selectByType(ardurobotml::Transition)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allOutgoingTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allOutgoingTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allOutgoingTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::State::intermediate_allInputTransition2Expression(an1 : Transition, an2 : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				 
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fireClock']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fireClock']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::State::intermediate_allInputTransition2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Transition, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allInputTransition'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_fireClock']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::State::allInputTransition2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		var sources : Sequence(Transition) := self.incomingTransitions->selectByType(ardurobotml::Transition)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allInputTransition2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allInputTransition2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::Transition::sensitiveEvent2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_SampledOn_sensitiveEvent';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "SampledOn")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.source.oclAsType(ardurobotml::State).oclAsType(EObject))+'_enteringClock']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnSampledClock' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.ownedGuard.oclAsType(ardurobotml::EventGuard).triggeringEvent.oclAsType(ardurobotml::FSMEvent).oclAsType(EObject))+'_happenedClock']->first();
					_abstract := seqOfAbstractEntity[name = 'SampledOnTrigger' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'SampledOn']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}



	 	mapping inMM1::FSMClock::tickClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_tickClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "ticks")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_tickClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::TFSM::initializeEvent2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_initializeEvent';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "initialize")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_initializeEvent';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::Action::beginClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_beginClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "begin")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_beginClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Action::endClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_endClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "end")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_endClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::State::enteringClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_enteringClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onEnter")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_enteringClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::State::leavingClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_leavingClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onLeave")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_leavingClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::Transition::fireClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_fireClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "fire")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_fireClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::FSMEvent::happenedClock2Clock() :TimeModel::Clock 
			when {  }
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_happenedClock';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_happenedClock';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM1::FSMEvent::noTickingUntilFSMInitialized252noTickingUntilFSMInitialized(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_noTickingUntilFSMInitialized";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(ecore::EObject).eContainer().oclAsType(ardurobotml::TFSM).oclAsType(EObject))+'_initializeEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map firstHappenedClock2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Action::beginThenEndInvariant12beginThenEndInvariant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_beginThenEndInvariant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_beginClock']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_endClock']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Action::tickAfterLast882tickAfterLast(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				((self.oclAsType(ecore::EObject).eContainer().oclIsKindOf(ardurobotml::State))
	 		and (self.oclAsType(ecore::EObject).eContainer().oclAsType(ardurobotml::State).actions->first() <> self)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_tickAfterLast";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := theMainBlock.elements[name = getNameOrUID(self
											.oclAsType(ecore::EObject)
											.eContainer()
											.oclAsType(ardurobotml::State)
											.actions->at(self
															.oclAsType(ecore::EObject)
															.eContainer()
															.oclAsType(ardurobotml::State)
															.actions->indexOf(self)-1)
											.oclAsType(ardurobotml::Action)
											.oclAsType(EObject))+'_endClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_beginClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::TFSM::initializeOnlyOnceInvariant82initializeOnlyOnceInvariant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_initializeOnlyOnceInvariant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_initializeEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map oneTickOnlyClock2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::TFSM::initFirstInvariant12initFirstInvariant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_initFirstInvariant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_initializeEvent']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.initialState.oclAsType(ardurobotml::State).oclAsType(EObject))+'_enteringClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM1::TFSM::intermediate_oneTransitionAtATime12oneTransitionAtATime(an1 : Transition, an2 : Transition, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneTransitionAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
		seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_fireClock']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_fireClock']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM1::TFSM::oneTransitionAtATime12oneTransitionAtATime()
	{
		init{
			var sources : Sequence(Transition) := self.ownedStates.outgoingTransitions->selectByType(ardurobotml::Transition)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneTransitionAtATime12oneTransitionAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		

//relation stuff		
	
		mapping inMM1::State::enterThenLeaveInvariant12enterThenLeaveInvariant(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_enterThenLeaveInvariant";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_enteringClock']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leavingClock']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM1::State::intermediate_oneActionAtATime12oneActionAtATime(an1 : Action, an2 : Action, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneActionAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
		seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_beginClock']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_beginClock']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM1::State::oneActionAtATime12oneActionAtATime()
	{
		init{
			var sources : Sequence(Action) := self.actions->selectByType(ardurobotml::Action)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneActionAtATime12oneActionAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM1::State::tickWhenEnteringState272tickWhenEnteringState(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.actions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_tickWhenEnteringState";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_enteringClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := theMainBlock.elements[name = getNameOrUID(self.actions->first().oclAsType(ardurobotml::Action).oclAsType(EObject))+'_beginClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::State::leaveWhenOneTransitionFires252leaveWhenOneTransitionFires(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.outgoingTransitions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_leaveWhenOneTransitionFires";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allOutgoingTransition2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leavingClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::State::enterWhenOneTransitionFires252enterWhenOneTransitionFires(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.incomingTransitions->size() > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_enterWhenOneTransitionFires";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allInputTransition2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_enteringClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Transition::fireWhenLasActionEnds492fireWhenLasActionEnds(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard <> null
			and self.ownedGuard.oclIsKindOf(ardurobotml::EvaluateGuard)
			and self.ownedGuard.oclAsType(ardurobotml::EvaluateGuard).condition.oclIsKindOf(ardurobotml::AllActionFinishedCondition)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_fireWhenLasActionEnds";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := theMainBlock.elements[name = getNameOrUID(self.source.actions->last().oclAsType(ardurobotml::Action).oclAsType(EObject))+'_endClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fireClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Transition::fireWhenEventHappens502fireWhenEventHappens(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard <> null
			and self.ownedGuard.oclIsKindOf(ardurobotml::EventGuard)) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_fireWhenEventHappens";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map sensitiveEvent2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fireClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Transition::fireWhenNoGuard222fireWhenNoGuard(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.ownedGuard = null) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_fireWhenNoGuard";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_leavingClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_fireClock']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		





















mapping inMM1::Package::ardurobotml2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(Clock)->asSequence()->first().oclAsType(EObject));
		}; 
		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FSMClock.oclAsType(EClass)).oclAsType(FSMClock)->map tickClock2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), TFSM.oclAsType(EClass)).oclAsType(TFSM)->map initializeEvent2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map beginClock2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Action.oclAsType(EClass)).oclAsType(Action)->map endClock2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map enteringClock2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), State.oclAsType(EClass)).oclAsType(State)->map leavingClock2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Transition.oclAsType(EClass)).oclAsType(Transition)->map fireClock2MSE();




		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), FSMEvent.oclAsType(EClass)).oclAsType(FSMEvent)->map happenedClock2MSE();




		





		





		





		





		







	}		


	 	mapping inMM1::FSMClock::tickClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_tickClock';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "ticks")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_tickClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::TFSM::initializeEvent2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_initializeEvent';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "initialize")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_initializeEvent')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Action::beginClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_beginClock';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "begin")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_beginClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Action::endClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_endClock';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "end")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_endClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::State::enteringClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_enteringClock';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onEnter")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_enteringClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::State::leavingClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_leavingClock';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "onLeave")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_leavingClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Transition::fireClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_fireClock';
				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "fire")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_fireClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::FSMEvent::happenedClock2MSE() :FeedBack::ModelSpecificEvent 
			when {  }
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_happenedClock';
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_happenedClock')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		










